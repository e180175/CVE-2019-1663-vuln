## How does it works ? Pretty straightforward :

1. First I learned that Cisco RV130W exposes a login form (as a gateway to the configuration menu)
2. Then I started investigating the function to understand a bit better what it does.
3. !!Found usage of user controlled parameters (password and such) without any checks on the len before executing strcpy
4. Passing 'big value' as parameters of the POST request (login form) could result in the application crashing

> Simple case of stack buffer overflow.

## How this vuln could have been found ? 

My hypothesis is that fuzzing was used on the POST request's parameters
Then by following the call stack when the crash happened, we could have pin-pointed the instruction causing this mess.

```txt
Here are some missing references I couldn't figure out but do we really care ?
  ## PARAM
  int param_4

  ## VAR
  int iVar7
  undefined2 local_32

  ## DATA
  &DAT_00089a4c
  &DAT_00081240
  &DAT_000816f4
  &DAT_000899d8

  ## FUNC
  FUN_0002648c
```

```c
/*
[CVE-2019-1663_VULN]
Author: Frédéric Willems

Took some time to reverse it but I think I've done a great job.

*/

// Define the semantics for success and failure error codes.
// https://github.com/firmadyne/libnvram/blob/master/config.h#L27
#define E_FAILURE  0
#define E_SUCCESS  1

// Shadows 'magic numbers' for better understanding
typedef LOGIN_CODE {
  FAILURE = 0,
  TMOUT = 1,
  ALREADY_LOGGED = 2,
  SUCCESS = 3
}

/* 
  FUN_0002c614 -> FUN_0002c4b0 -> login (FUN_0002bf64)
  Call to FUN_0002c614 which seems to handle all the logic of the webserver, then
  Call to FUN_0002c4b0 which seems to check if the user is logged or not

  The login function validates the user's data passed from the POST request.
  Multiple checks are performed to unsure that the password and login matche the ones stored in nvram

  The nvram is likely memory used to store configuration metrics
  Pretty easy to use: https://github.com/firmadyne/libnvram/blob/master/nvram.h
  
  I attempted to clean the code using ghidra rename feature,
  but since the compiler performed optimization on memory usage (variables seem to have been reused sometimes),
  I used my good ol' friend sublime text instead.
*/
int login(char *gui_user,char *pwd,char *data,int param_4)
{
  int iVar7;
  
  // File descriptor (console)
  FILE *console;

  // memset(*,0,100); replaced by:
  char gui_pwd     [100] = {0};
  char nv_pwd      [100] = {0};
  char enc         [100] = {0};
  char nv_user     [100] = {0};

  char *admin_timeout;
  char *session_key;
  char *auth_time;

  long auth_time_l;
  bool guest;

  int uptime;
  int return_code;

  // concat init in one line and cleanup
  // not sure of the type for this one (bool?)
  undefined2 local_32 = 0;

  sscanf(data,"%[^,],%[^,],%[^\n]",&local_32,enc,nv_user);

  if (param_4 == 0) {
    if (strncmp(enc,"enc=",4)) {
      // strcpy(nv_pwd,enc);
      // pwd comes from the user's post request,
      // since it's copied using strcpy,
      // we can overflow the buffer by sending a lot of chars (>100)
      strcpy(gui_pwd, pwd);
      // removed debug instruction bc we don't care ?
    }
    // Called this function md5_smth bc I don't realy know what it does, 
    // except maybe checking if the password provided is the same as the one stored in the nvram ?
    md5_smth(pwd,gui_pwd);
    sscanf(enc,"enc=%s",nv_pwd);
    if (strlen(nv_user) != strlen(gui_user)) goto LOGIN_FAILED;
  }
  else {
    if (strncmp(enc,"enc=",4)) {
      sscanf(enc,"enc=%s",nv_pwd);
    }
    else {
      md5_smth(enc,nv_pwd);
    }
    strcpy(gui_pwd,pwd);
    console = fopen("/dev/console","w");
    if (console == NULL) goto LOGIN_FAILED;

    fprintf(console,"%s(): \n =========>valid user: nv_user=%s, gui_user=%s, gui_pwd=%s, nv_pwd=%s\n",
      "valid_user",nv_user,gui_user,gui_pwd,nv_pwd);
    fclose(console);

    if (strlen(nv_user) != strlen(gui_user)){
      goto LOGIN_FAILED;
    }
  }
  if ((((strlen(nv_pwd) != strlen(gui_pwd)) 
    || (strcmp(nv_user,gui_user) != 0)) 
    || (strcmp(nv_pwd,gui_pwd) != 0)) 
    || ((nvram_match("en_guest",&DAT_00089a4c) != E_FAILURE 
    && (nvram_match("http_power","r") != E_FAILURE)))) {
LOGIN_FAILED:

    if (FUN_0002648c(gui_user) != 0) {
      syslog(6,"Web management login failed, user=%s\n",gui_user);
    }

    return FAILURE;
  }

  uptime = get_uptime();
  auth_time = nvram_get("auth_time");
  if (auth_time == NULL) auth_time = "";

  iVar7 = nvram_match("http_power",&DAT_00081240);
  if (iVar7 == E_FAILURE) {
    iVar7 = 0;
CHECK_TIMEOUT:
    auth_time_l = atol(auth_time);
    if ((uptime < auth_time_l) || (iVar7 <= uptime - auth_time_l)) {
      syslog(6,"Administrator session timeout.");
      guest = true;
      goto TIMEOUT;
    }
  }
  else {
    admin_timeout = nvram_get("admin_timeout")
    if (admin_timeout == NULL) admin_timeout = "";
    iVar7 = atoi(admin_timeout);
    if (iVar7 != 99) {
      iVar7 = iVar7 * 60;
      goto CHECK_TIMEOUT;
    }
  }
  guest = false;
TIMEOUT:
  if (nvram_match("auth_st",&DAT_000899d8 == E_FAILURE 
    || nvram_match("http_power",&DAT_00081240) == E_FAILURE) 
    || guest) {
    nvram_set("http_power",&local_32);
    session_key = nvram_get("session_key");
    if (session_key == NULL) {
      session_key = "";
    }
    return_code = TMOUT;
    FUN_0001f8fc(session_key,&DAT_000816f4);
  }
  else {
    if (strcmp(&local_32,"rw") == 0) {
      session_key = nvram_get("session_key");
      if (session_key == NULL) {
        session_key = "";
      }
      nvram_set("tmp_auth_key",session_key);
      console = fopen("/dev/console","w");
      if (console != NULL) {
        fwrite("If you want to close the other session, please click on \'Continue\' button. Click \'Cancel\' to Logout.\n"
               ,1,101,console);
        fclose(console);
      }
      return_code = SUCCESS;
    }
    else {
      console = fopen("/dev/console","w");
      if (console != NULL) {
        fwrite("Administrator already logged in. You cannot login using Guest account.\n",1,72,console);
        fclose(console);
      }
      return_code = ALREADY_LOGGED;
    }
  }
  syslog(6,"Web management login success, user=%s\n",gui_user);
  return return_code;
}
```